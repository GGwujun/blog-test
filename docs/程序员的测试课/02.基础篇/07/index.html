<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
    <link rel="stylesheet" href="/blog-test/umi.css" />
    <script>
      window.routerBase = "/blog-test";
    </script>
    <script>
      //! umi version: 3.5.41
    </script>
    <script>
      !(function () {
        var e =
            navigator.cookieEnabled && void 0 !== window.localStorage
              ? localStorage.getItem("dumi:prefers-color")
              : "auto",
          o = window.matchMedia("(prefers-color-scheme: dark)").matches,
          t = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === t[2] ? (o ? t[1] : t[0]) : t.indexOf(e) > -1 ? e : t[0]
        );
      })();
    </script>
    <title>07 | Mock 框架：怎么让测试变得可控？ - 大师兄</title>
  </head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/程序员的测试课/02.基础篇/07" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/">大师兄</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span>计算机基础</span><span>算法</span><span>前端开发<ul><li><a href="/blog-test/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li></ul></span><span>前端工程化</span><span>前端性能优化</span><span>移动端开发</span><span>软件测试<ul><li><a href="/blog-test/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog-test/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-test/接口测试入门课">接口测试入门课</a></li><li><a aria-current="page" class="active" href="/blog-test/程序员的测试课">程序员的测试课</a></li><li><a href="/blog-test/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog-test/软件测试52讲">软件测试52讲</a></li></ul></span><span>产品与用户体验<ul><li><a href="/blog-test/成为ai产品经理">成为ai产品经理</a></li><li><a href="/blog-test/硅谷产品实战36讲">硅谷产品实战36讲</a></li><li><a href="/blog-test/苏杰的产品创新课">苏杰的产品创新课</a></li></ul></span><span>面试</span><span>杂谈<ul><li><a href="/blog-test/b测试从0到1">b测试从0到1</a></li><li><a href="/blog-test/tob市场品牌实战课">tob市场品牌实战课</a></li><li><a href="/blog-test/从0开始做增长">从0开始做增长</a></li></ul></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" style="background-image:url(&#x27;/logo.png&#x27;)" href="/blog-test/"></a><h1>大师兄</h1><p></p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li>计算机基础</li><li>算法</li><li>前端开发<ul><li><a href="/blog-test/新时代产品经理进阶之路">新时代产品经理进阶之路</a></li></ul></li><li>前端工程化</li><li>前端性能优化</li><li>移动端开发</li><li>软件测试<ul><li><a href="/blog-test/全链路压测实战30讲">全链路压测实战30讲</a></li><li><a href="/blog-test/性能测试实战30讲">性能测试实战30讲</a></li><li><a href="/blog-test/接口测试入门课">接口测试入门课</a></li><li><a aria-current="page" class="active" href="/blog-test/程序员的测试课">程序员的测试课</a></li><li><a href="/blog-test/自动化测试高手课">自动化测试高手课</a></li><li><a href="/blog-test/软件测试52讲">软件测试52讲</a></li></ul></li><li>产品与用户体验<ul><li><a href="/blog-test/成为ai产品经理">成为ai产品经理</a></li><li><a href="/blog-test/硅谷产品实战36讲">硅谷产品实战36讲</a></li><li><a href="/blog-test/苏杰的产品创新课">苏杰的产品创新课</a></li></ul></li><li>面试</li><li>杂谈<ul><li><a href="/blog-test/b测试从0到1">b测试从0到1</a></li><li><a href="/blog-test/tob市场品牌实战课">tob市场品牌实战课</a></li><li><a href="/blog-test/从0开始做增长">从0开始做增长</a></li></ul></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/blog-test/程序员的测试课">程序员的测试课</a></li><li><a href="/blog-test/程序员的测试课/01.开篇词">01.开篇词</a><ul><li><a href="/blog-test/程序员的测试课/01.开篇词/01"><span>开篇词 | 为什么写测试是程序员的本职工作？</span></a></li></ul></li><li><a aria-current="page" class="active" href="/blog-test/程序员的测试课/02.基础篇">02.基础篇</a><ul><li><a href="/blog-test/程序员的测试课/02.基础篇/01"><span>01 | 实战：实现一个 ToDo 的应用（上）</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/02"><span>02 | 实战：实现一个 ToDo 的应用（下）</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/03"><span>03 | 程序员的测试与测试人员的测试有什么不同？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/04"><span>04 | 自动化测试：为什么程序员做测试其实是有优势的？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/05"><span>05 | 一个好的自动化测试长什么样？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/06"><span>06 | 测试不好做，为什么会和设计有关系？</span></a></li><li><a aria-current="page" class="active" href="/blog-test/程序员的测试课/02.基础篇/07"><span>07 | Mock 框架：怎么让测试变得可控？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/08"><span>08 | 单元测试应该怎么写？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/09"><span>09 | 测试覆盖率：如何找出没有测试到的代码？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/10"><span>10 | 为什么 100% 的测试覆盖率是可以做到的？</span></a></li><li><a href="/blog-test/程序员的测试课/02.基础篇/11"><span>11 | 集成测试：单元测试可以解决所有问题吗？</span></a></li></ul></li><li><a href="/blog-test/程序员的测试课/03.应用篇">03.应用篇</a><ul><li><a href="/blog-test/程序员的测试课/03.应用篇/01"><span>12 | 实战：将 ToDo 应用扩展为一个 REST 服务</span></a></li><li><a href="/blog-test/程序员的测试课/03.应用篇/02"><span>13 | 在 Spring 项目中如何进行单元测试？</span></a></li><li><a href="/blog-test/程序员的测试课/03.应用篇/03"><span>14 | 在 Spring 项目如何进行集成测试？</span></a></li><li><a href="/blog-test/程序员的测试课/03.应用篇/04"><span>15 | 测试应该怎么配比？</span></a></li><li><a href="/blog-test/程序员的测试课/03.应用篇/05"><span>16 | 怎么在遗留系统上写测试？</span></a></li></ul></li><li><a href="/blog-test/程序员的测试课/04.扩展篇">04.扩展篇</a><ul><li><a href="/blog-test/程序员的测试课/04.扩展篇/01"><span>17 | TDD 就是先写测试后写代码吗？</span></a></li><li><a href="/blog-test/程序员的测试课/04.扩展篇/02"><span>18 | BDD 是什么东西？</span></a></li></ul></li><li><a href="/blog-test/程序员的测试课/05.加餐">05.加餐</a><ul><li><a href="/blog-test/程序员的测试课/05.加餐/01"><span>答疑解惑 | 那些东西怎么测？</span></a></li></ul></li><li><a href="/blog-test/程序员的测试课/06.结束语">06.结束语</a><ul><li><a href="/blog-test/程序员的测试课/06.结束语/01"><span>结束语 | 对代码的信心要从测试里来</span></a></li></ul></li><li><a href="/blog-test/程序员的测试课/summary">程序员的测试课</a></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="从模式到框架" data-depth="2"><a href="/blog-test/程序员的测试课/02.基础篇/07#从模式到框架"><span>从模式到框架</span></a></li><li title="Mock 框架" data-depth="2"><a href="/blog-test/程序员的测试课/02.基础篇/07#mock-框架"><span>Mock 框架</span></a></li><li title="设置 Mock 对象" data-depth="3"><a href="/blog-test/程序员的测试课/02.基础篇/07#设置-mock-对象"><span>设置 Mock 对象</span></a></li><li title="校验对象行为" data-depth="3"><a href="/blog-test/程序员的测试课/02.基础篇/07#校验对象行为"><span>校验对象行为</span></a></li><li title="Mock 框架的延伸" data-depth="2"><a href="/blog-test/程序员的测试课/02.基础篇/07#mock-框架的延伸"><span>Mock 框架的延伸</span></a></li><li title="总结时刻" data-depth="2"><a href="/blog-test/程序员的测试课/02.基础篇/07#总结时刻"><span>总结时刻</span></a></li><li title="思考题" data-depth="2"><a href="/blog-test/程序员的测试课/02.基础篇/07#思考题"><span>思考题</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="07--mock-框架怎么让测试变得可控"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#07--mock-框架怎么让测试变得可控"><span class="icon icon-link"></span></a>07 | Mock 框架：怎么让测试变得可控？</h1><p>你好，我是郑晔！</p><p>上一讲，我们谈到测试不好测，关键是软件设计问题。一个好的设计可以把很多实现细节从业务代码中隔离出去。</p><p>之所以要隔离出去，一个重要的原因就是这些实现细节不那么可控。比如，如果我们依赖了数据库，就需要保证这个数据库环境同时只有一个测试在用。理论上这样不是不可能，但成本会非常高。再比如，如果依赖了第三方服务，那么我们就没法控制它给我们返回预期的值。这样一来，很多出错的场景，我们可能都没法测试。</p><p>所以，在测试里，我们不能依赖于这些好不容易隔离出去的细节。否则，测试就会变得不稳定，这也是很多团队测试难做的重要原因。不依赖于这些细节，那我们的测试总需要有一个实现出现在所需组件的位置上吧？或许你已经想到答案了，没错，这就是我们这一讲要讲的 Mock 框架。</p><h2 id="从模式到框架"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#从模式到框架"><span class="icon icon-link"></span></a>从模式到框架</h2><p>**做测试，本质上就是在一个可控的环境下对被测系统/组件进行各种试探。**拥有大量依赖于第三方代码，最大的问题就是不可控。</p><p>怎么把不可控变成可控？第一步自然是隔离，第二步就是用一个可控的组件代替不可控的组件。换言之，用一个假的组件代替真的组件。</p><p>这种用假组件代替真组件的做法，在测试中屡见不鲜，几乎成了标准的做法。但是，因为各种做法又有细微的差别，所以，如果你去了解这个具体做法会看到很多不同的名词，比如：Stub、Dummy、Fake、Spy、Mock 等等。实话说，你今天问我这些名词的差异，我也需要去查找相关的资料，不能给出一个立即的答复。它们之间确实存在差异，但差异几乎到了可以忽略不计的份上。</p><p>Gerard Meszaros 写过一本《<a target="_blank" rel="noopener noreferrer" href="https://book.douban.com/subject/1859393/">xUnit Test Patterns<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》，他给这些名词起了一个统一的名字，形成了一个新的模式：<a target="_blank" rel="noopener noreferrer" href="https://martinfowler.com/bliki/TestDouble.html">Test Double（测试替身）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。其基本结构如下图所示。</p><p><img src="/images/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AF%BE/02.%E5%9F%BA%E7%A1%80%E7%AF%87/resourceimage0a290a9ac08ddf1de69e90d917c36fe37929.jpg" alt=""/></p><p>在这个图里，SUT 指的是被测系统（System Under Test），Test Double 就是与 SUT 进行交互的一个组件。有了我们之前的讲解，这个图应该不难看懂。</p><p>然而，这个名字也没有在业界得到足够广泛的传播，你更熟悉的说法应该是 Mock 对象。因为后来在这个模式广泛流行起来之前，Mock 框架先流行了起来。</p><h2 id="mock-框架"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#mock-框架"><span class="icon icon-link"></span></a>Mock 框架</h2><p>Mock 框架的基本逻辑很简单，创建一个模拟对象并设置它的行为，主要就是用什么样的参数调用时，给出怎样的反馈。虽然 Mock 框架本身的逻辑很简单，但前期也经过了很长一段时间的发展，什么东西可以 Mock 以及怎样去表现 Mock，不同的 Mock 框架给出了不同的答案。</p><p>今天我们的讨论就以 Mockito 这个框架作为我们讨论的基础，这也是目前 Java 社区最常用的 Mock 框架。</p><p>要学习 Mock 框架，必须要掌握它最核心的两个点：<strong>设置模拟对象</strong>与<strong>校验对象行为</strong>。</p><h3 id="设置-mock-对象"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#设置-mock-对象"><span class="icon icon-link"></span></a>设置 Mock 对象</h3><p>要设置一个模拟对象，首先要创建一个模拟对象。在实战中，我们已经见识过了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">TodoItemRepository repository = mock(TodoItemRepository.class);</span></div></pre></div><p>接下来就是设置它的行为，下面是从实战中摘取的两个例子。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">when(repository.findAll()).thenReturn(of(new TodoItem(&quot;foo&quot;)));</span></div><div class="token-line"><span class="token plain">    when(repository.save(any())).then(returnsFirstArg());</span></div></pre></div><p>一个好程序库其 API 要有很强的表达性，像前面这两段代码，即便我不解释，看语句本身也知道它做了些什么。</p><p><strong>模拟对象的设置核心就是两点：参数是什么样的以及对应的处理是什么样的。</strong></p><p>参数设置其实是一个参数匹配的过程，核心要回答的问题就是判断给出的实参是否满足这里设置的条件。像上面代码中，save 的写法表示任意参数都可以，我们也可以设置它是特定的值，比如像下面这样。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">when(repository.findByIndex(1)).thenReturn(new TodoItem(&quot;foo&quot;));</span></div></pre></div><p>其实它也是一个参数匹配的过程，只不过这里做了些省略，完整的写法应该是下面这样。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">when(repository.findByIndex(eq(1))).thenReturn(new TodoItem(&quot;foo&quot;));</span></div></pre></div><p>如果你有更复杂的参数匹配过程，甚至可以自己去实现一个匹配过程。但我强烈建议你不要这么做，因为测试应该是简单的。一般来说，<strong>相等和任意参数这两种用法在大多数情况下已经够用了。</strong></p><p>设置完参数，接下来，就是对应的处理。能够设置相应的处理，这是体现模拟对象可控的关键。前面的例子我们看到了如何设置相应的返回值，我们也可以抛出异常，模拟异常场景。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">when(repository.save(any())).thenThrow(IllegalArgumentException.class);</span></div></pre></div><p>同设置参数类似，相应的处理也可以写得很复杂，但我同样建议你不要这么做，原因也是一样的，测试要简单。<strong>知道怎样设置返回值，怎样抛出异常，已经足够大多数情况下使用了。</strong></p><h3 id="校验对象行为"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#校验对象行为"><span class="icon icon-link"></span></a>校验对象行为</h3><p>模拟对象的另外一个重要行为是校验对象行为，就是知道一个方法有没有按照预期的方式调用。比如，我们可以预期 save 函数在执行过程中得到了调用。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">verify(repository).save(any());</span></div></pre></div><p>这只是校验了 save 方法得到了调用，我们还可以校验这个方法调用了多少次。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">verify(repository, atLeast(3)).save(any());</span></div></pre></div><p>同样，校验也有很多可以设置的参数，但我同样不建议你把它用得太复杂了，<strong>就连verify 本身我都建议你不要用得太多</strong>。</p><p>verify 用起来会给人一种安全感，所以，会让人有一种多用的倾向，但这是一种错觉。我在讲测试框架时说过，verify 其实是一种断言。断言意味着这是一个函数应该具备的行为，是一种行为上的约定。</p><p>一旦设置了 verify，实际上也就约束了函数的实现。但 verify 约束的对象又是底层的组件，是一种实现细节。换言之，过度使用 verify 造成的结果就是把一个函数的实现细节约定死了。</p><p>过度使用 verify，在写代码的时候，你会有一种成就感。但是，一旦涉及代码修改，整个人就不好了。因为实现细节被 verify 锁定死，一旦修改代码，这些 verify 就很容易造成测试无法通过。</p><p><strong>测试应该测试的是接口行为，而不是内部实现</strong>。所以，verify 虽好，还是建议少用。如果有一些场景不用 verify 就没有什么可断言的了，那该用 verify 还是要用。</p><p>如果按照测试模式来说，设置 Mock 对象的行为应该算是 Stub，而校验对象行为的做法，才是 Mock。<strong>如果按照模式的说法，我们应该常用 Stub，少用 Mock。</strong></p><h2 id="mock-框架的延伸"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#mock-框架的延伸"><span class="icon icon-link"></span></a>Mock 框架的延伸</h2><p>Mock 框架的主要作用是模拟对象的行为，但作为一种软件设计思想，它却有着更大的影响。既然我们可以模拟对象行为，那本质上来说，我们也可以模拟其它东西。所以，后面也有一些基于这种模拟思想的框架，其中，目前行业中使用最为广泛的是模拟服务器。</p><p>模拟服务器顾名思义，它模拟的是服务器行为，现在在行业中广泛使用的模拟服务器主要是 HTTP 模拟服务器。HTTP 服务器的主要行为就是收到一个请求之后，给出一个应答，从行为上说，这与对象接受一系列参数，给出相应的处理如出一辙。</p><p>接下来我就以 Moco 为例，简单介绍一下模拟服务器。<a target="_blank" rel="noopener noreferrer" href="https://github.com/dreamhead/moco">Moco<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是我自己编写的一个开源模拟服务器程序库，曾在 2013 年获得 Oracle 的 Duke 选择奖。（在《软件设计之美》中讲到程序库的设计时，我讲过 <a target="_blank" rel="noopener noreferrer" href="https://time.geekbang.org/column/article/267856">Moco 整个设计的来龙去脉<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。如果你有兴趣，可以去回顾一下。）</p><p>下面是一个使用了 Moco 的测试代码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">public void should_return_expected_response() {</span></div><div class="token-line"><span class="token plain">      // 设置模拟服务器的信息</span></div><div class="token-line"><span class="token plain">      // 设置服务器访问的端口</span></div><div class="token-line"><span class="token plain">      HttpServer server = httpServer(12306);</span></div><div class="token-line"><span class="token plain">      // 访问/foo 这个 URI 时，返回 bar</span></div><div class="token-line"><span class="token plain">      server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;); </span></div><div class="token-line"><span class="token plain">      </span></div><div class="token-line"><span class="token plain">      // 开始执行测试</span></div><div class="token-line"><span class="token plain">      running(server, () -&gt; {</span></div><div class="token-line"><span class="token plain">        // 这里用了 Apache HTTP库访问模拟服务器，实际上，可以使用你的真实项目</span></div><div class="token-line"><span class="token plain">        Content content = Request.Get(&quot;http://localhost:12306/foo&quot;)</span></div><div class="token-line"><span class="token plain">          .execute()</span></div><div class="token-line"><span class="token plain">          .returnContent();</span></div><div class="token-line"><span class="token plain">          </span></div><div class="token-line"><span class="token plain">        // 对结果进行断言</span></div><div class="token-line"><span class="token plain">        assertThat(content.asString(), is(&quot;bar&quot;));</span></div><div class="token-line"><span class="token plain">      });</span></div><div class="token-line"><span class="token plain">    }</span></div></pre></div><p>在这段代码里，我们启动了一个 HTTP 服务器，当你访问 /foo 这个 URI 时，它会给你返回一个应答 bar。这其中最关键的一行代码就是设置请求应答的那行。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">server.request(by(uri(&quot;/foo&quot;))).response(&quot;bar&quot;);</span></div></pre></div><p>Moco 的 API 本身也有很强的表达性，通过代码本身你就能看到，这里就是设置了一个请求以及相应的应答。</p><p>Moco 的配置支持很多的 HTTP 元素，像下面这段代码，你可以同时匹配请求内容和 URI，也可以同时设置应答文本和 HTTP 的状态码。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">server</span></div><div class="token-line"><span class="token plain">      .request(and(by(&quot;foo&quot;), by(uri(&quot;/foo&quot;))))</span></div><div class="token-line"><span class="token plain">      .response(and(with(text(&quot;bar&quot;)), status(200)));</span></div></pre></div><p>在上面的例子里面，running 是负责模拟服务器启停的代码，里面包含的代码就是，通过自己真实的服务代码发出的真实请求。</p><p>Moco 还支持 verify，如果你想像 Mock 框架那样去校验服务器是否收到了相应的请求，就可以使用它。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">RequestHit hit = requestHit();</span></div><div class="token-line"><span class="token plain">    final HttpServer server = httpServer(port(), hit);</span></div><div class="token-line"><span class="token plain">    running(server, () -&gt; {</span></div><div class="token-line"><span class="token plain">      ...</span></div><div class="token-line"><span class="token plain">    })</span></div><div class="token-line"><span class="token plain">    </span></div><div class="token-line"><span class="token plain">    hit.verify(by(uri(&quot;/foo&quot;)), times(1));</span></div></pre></div><p>虽然 Moco 支持这样的能力，但同使用 Mock 框架类似，我也建议你少用 verify。</p><p>Moco 最大的价值就是让原本不可控的第三方 HTTP 服务器，现在可以按照我们预期的方式执行。比如，在真实的集成过程，你很难要求第三方服务器给你一个错误的应答，或者一个超时的应答，但使用 Moco 你就可以让它模拟出这样的行为。</p><p>Moco 还有一个很大的价值，原本你要做集成，唯一的选项是把整个系统跑起来，基本上就到了系统集成的范畴。而现在使用 Moco，验证工作可以用集成测试的代码就可以完成。作为程序员我们很清楚，相比于系统测试，这种做法轻太多了，一旦出现问题，定位起来也容易很多。从开发效率上看，这简直是数量级的提升。</p><p>Moco 不仅仅支持模拟 HTTP 服务器，还做了进一步延伸，支持模拟 WebSocket 服务器。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">HttpServer server = httpServer(12306);</span></div><div class="token-line"><span class="token plain">    webSocketServer = server.websocket(&quot;/ws&quot;);</span></div><div class="token-line"><span class="token plain">    webSocketServer.request(by(&quot;foo&quot;)).response(&quot;bar&quot;);</span></div></pre></div><p>无论是模拟 HTTP 服务器，还是模拟 WebSocket 服务器，本质上来说，它都是模拟对象这一思想的延伸。而所有这一切的出发点都是，我们希望在测试中得到一个可控的环境。</p><h2 id="总结时刻"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#总结时刻"><span class="icon icon-link"></span></a>总结时刻</h2><p>今天我们主要讲了 Mock 框架。Mock 框架是源自 Test Double（测试替身）这种测试模式。我们希望自己有一个可控的环境对被测系统/组件进行测试，背后的思想就是用假的却可控的组件去代替真实不可控的组件。</p><p>现在 Mock 框架已经成为了测试的重要组成部分，理解一个Mock框架核心就是要理解如何设置对象行为以及如何校验对象行为。设置对象行为主要是设置相应的参数以及对应的处理，无论这个处理是给出返回值，还是抛出异常。校验对象行为是一种断言，是看对象是否按照预期方式执行。不过，我给你提了一个醒，verify 虽好，尽量少用。</p><p>最后，我们还以 Moco 为例讲到了 Mock 框架的延伸，也就是模拟服务器。Moco 主要是模拟 HTTP 服务器，其核心就是对什么样的请求，给出什么样的应答。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>使用 Mock 框架，少用 verify。</strong></p><h2 id="思考题"><a aria-hidden="true" tabindex="-1" href="/blog-test/程序员的测试课/02.基础篇/07#思考题"><span class="icon icon-link"></span></a>思考题</h2><p>今天我们讲了 Mock 框架，你在实际工作中用到过 Mock 框架吗？它解决了你怎样的问题，或是你在使用它的过程中遇到怎样的困难，欢迎在留言区分享你的经验。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/GGwujun/blog/edit/master/ssrc/程序员的测试课/02.基础篇/07.md">在 GitHub 上编辑此页<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="最后更新时间：">2023/9/23 16:17:40</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script>
      (function () {
        if (!location.port) {
          (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
              i[r] ||
              function () {
                (i[r].q = i[r].q || []).push(arguments);
              }),
              (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
          })(
            window,
            document,
            "script",
            "//www.google-analytics.com/analytics.js",
            "ga"
          );
          ga("create", "UA-149864185-1", "auto");
          ga("send", "pageview");
        }
      })();
    </script>
    <script src="/blog-test/umi.js"></script>
  </body>
</html>
